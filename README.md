# ibvs_rpg_ws

## Introduction
The translation and rotation of the four-rotor UAV were decouped based on the visual servo method, the expected velocity v was calculated according to the image moment error, and the velocity v was tracked by NMPC. Meanwhile, I also take the vision restriction into consideration to prevent the loss of visual features.

## Requirements

- Python 3

- OpenCV 4+

- ROS Noetic

- Gazebo - ROS Noetic
## Package Installation
1. ```bash
	wget -c https://raw.githubusercontent.com/qboticslabs/ros_install_noetic/master/ros_install_noetic.sh && chmod +x ./ros_install_noetic.sh && ./ros_install_noetic.sh
	```
4. ```bash
	sudo apt-get install ros-noetic-desktop-full ros-noetic-joy ros-noetic-octomap-ros ros-noetic-mavlink protobuf-compiler libgoogle-glog-dev ros-noetic-control-toolbox python3-wstool python3-catkin-tools
	```
5. Prepare pip-python3:
   ```bash
	sudo curl https://bootstrap.pypa.io/get-pip.py | sudo python3 
	sudo curl https://bootstrap.pypa.io/get-pip.py | python3
	```
6. ```bash
   echo 'export PATH=$PATH:"$HOME/.local/bin"' >> ~/.bashrc
   source ~/.bashrc
	```
7.  Install the necessary packages of Python3
	```bash
	sudo python3 -m pip install -U rosdep catkin_pkg future 
	python3 -m pip install -U rosdep catkin_pkg future empy defusedxml numpy matplotlib imageio opencv-python
	```

## Usage

1. ```bash 
	git clone https://gitee.com/Hang_SJTU/ibvs_rpg_ws.git
    ```
2. ```
	catkin build
   ```
	**Declare**：Compile the workspace, Then in the devel/lib directory of this workspace directory, you can find the file `'librealsense_gazebo_plugin.so'` (or possibly `'librealsense_ros_gazebo.so'`, and rename it as `'librealsense_gazebo_plugin.so'`) Copy and paste it under `/opt/ros/noetic/lib/`

3. ```
   source devel/setup.bash
   ```

4. ```
   roslaunch rpg_rotors_interface quadrotor_empty_world.launch #target:=circle
   ```
	**Declare**：Launch the Gazebo simulation and drone model file (use_mpc=true)
	Then you need to let the quadrotor fly to the position (-3.5m, 0.0m, 1.0m) using the rqt_gui:
	1. Click `connect`
	2. Click `Arm Bridge`
	3. Click `Start`
	As the initial position is set to be (-3.5m, 0.0m, 1.0m), after clicking the three buttons, the quadrotor is supposed to fly to (-3.5m, 0.0m, 1.0m) approximately. (position z may be 0.87m)

5. ```
   roslaunch ibvs_pkg ibvs_circle.launch # for circle world
   roslaunch ibvs_pkg ibvs_aruco.launch # for aruco world
   ```

   **Declare**：Start the image moment computing node of the visual feature and publish the expected speed calculated according to the image moment error topic: `"/hummingbird/reference_vel"`

7. ```
   roslaunch mpc_pkg mpc_acados_controller.launch # nmpc based on acados 
   roslaunch mpc_pkg mpc_acado_controller.launch  # nmpc based on acado(bad result)
   ```

   **Declare**：Based on the expected speed and IMU feedback attitude estimated by VIO, the C++ code generated by **ACADO** or the Python code of **ACADOS** is used to construct the nmpc model for calculation, and the thrust and 3 direction bodyrates are the output to the underlying controller. 
## Problem
 - [ ] **SO CONFUSED!!!!!**
Current MPC bug, the results calculated by the C code generated based on **ACADO** framework's code generation are inconsistent with the original framework's calculation results (same input), only when the visual features contraints are added into the model.

#### Afterthat, I use **ACADOS** instead of **ACADO** to solve the visual features contraints problem and get ideal results, but the previous problem of **ACADO** still remains.

## Example
When the state is:

    -3.500000e-00	0.000000e-00	8.700000e-01	1.000000e+00	-1.006178e-08	1.105300e-07	
    -2.714890e-05	4.464836e-08	-4.052675e-08	1.316640e-09	-1.449783e-01	-2.055663e-01	
    2.829000e+00	1.536338e-01	-2.077302e-01	2.829000e+00	1.557976e-01	9.304581e-02	
    2.829000e+00	-1.428145e-01	9.304581e-02	2.829000e+00
whichi means:
1. position (p_x, p_y ,p_z) is `(-3.500000e-00,	 0.000000e-00,	 8.700000e-01)`;
2. quaterniond (q_w, q_x, q_y, q_z) is `(1.000000e+00,	-1.006178e-08,	 1.105300e-07,	-2.714890e-05)`;
3. velocity (v_x, v_y, v_z) is `(4.464836e-08, -4.052675e-08, 1.316640e-09)`;
4. visual feature (p1_u, p1_v, p1_z, p2_u, p2_v, p2_z, p3_u, p3_v, p3_z, p4_u, p4_v, p4_z)  is `(-1.449783e-01, -2.055663e-01, 2.829000e+00, 1.536338e-01, -2.077302e-01, 2.829000e+00, 1.557976e-01, 9.304581e-02 2.829000e+00, -1.428145e-01, 9.304581e-02, 2.829000e+00)`.
